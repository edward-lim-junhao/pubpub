# Handling fields in the integrations API
## Kalil's proposal
### PubPub core integrations API
- Clients using the /pubs endpoint (read and write) will reference fields by slugs, not ids. These slugs are aliases controlled by the developer of the integration. When an integration (not an instance) is created, PubPub generates and stores a default set of aliases for that integration, which can then be modified by the integration developer in the developer portal.
- Since field slugs must be globally unique, they will be namespaced according to the field creator
    - If the creator is an integration dev, we use the integration's name (e.g. "datacite/doi")
    - If the creator is a community member, we use the community's name (e.g. "arcadia/title")
- These aliases are a JSON column in the integrations table that maps the aliases to IDs in the PubFields table and takes the form {"namespace/name": "Field id"}, where "name" is the editable alias that the integration developer uses to refer to that field.

### Developer portal (integrations admin page)
- The developer portal will allow integration developers to:
    - Select existing fields that their integration will request read/write permissions for
    - Manage their field aliases
    - Create and revoke API keys
- Integration manifests are created in the developer portal, then downloaded. These manifests will contain the field names map and the requested permissions and be used by the API client SDK to provide type hints.

### PubPub field creation
- Fields are initially registered not in the manifest, but in the PubPub core UI
    - Community members will create fields as well and they won't be doing it through manifests
    - This also lets PubPub core provide feedback and validation immediately when users create fields. This will be especially important when we build field validation, which will require a more complex UI.
- Fields have the following properties:
    - (Default) display name
        - The display name is human readable and unstable. This can be set by the community, but not by the integration author. It should be used in user facing UI elements like forms by both PubPub core and integrations. Examples: "Title", "Titre"
    - (Default) slug
        - The slug is also human readable, but stable. This slug must also be unique, so it is namespaced either to the integration or community that created it. The developer can set an alias to use instead of this in the developer portal, but otherwise it will not change.
This is a unique, human readable identifier for the field. When a new field (or new integration) is created, this is the name that will be added to integration developers' alias maps. This can be changed by the original creator, but those changes will not affect existing alias maps. Examples: "core/title", "arcadia/title", "reviews/review-title"
    - ID
        - This is a unique, fixed identifier, generated by the database.

### PubPub field renaming

#### What happens when the creator of a field updates its default slug or default display name?
Existing integrations continue to refer to that field by its old name, or whatever custom alias they had defined. Newly created integrations will use the new name by default.

#### What happens when an integration developer updates their alias map?
Changing the name of a field already in use could cause an integration to break, so it must be done carefully alongside updating the integration's code. To make this possible without downtime, the developer portal should have a button to "Deprecate" a field alias which would prompt the user to enter the new alias. PubPub would add an entry to the alias map from the new alias to that field ID, but wouldn't remove the old entry yet. Now PubPub will accept put requests that refer to the field by either alias, and read requests will include the same value duplicated with both aliases. The developer can then update the integration's code to use the new alias. Once the new version of the integration is deployed, they can return to the developer portal and complete the deprecation, which will delete the old entry from their alias map.

## Alternatives considered

### Problem: handling field renaming
- Allow the creator of a field to rename it whenever they like and always use IDs to refer to fields
    - Pro: Allows fields to be renamed safely without additional work
    - Con: API requests and responses are unintelligible by humans, which makes debugging miserable
- Take the airtable approach and accept IDs or slugs, but encourage users to use IDs
    - This approach allows the integration developer to trade stability for an improved developer experience. Since the stability of pubpub depends on the stability of these integrations, we shouldn't encourage them to make choices that will lead to downtime.
- Refer to fields by slugs, but disallow users from renaming them
    - Pro: No need for aliasing
    - Con: Field slugs might become obsolete or confusing. We can mitigate that a lot by allowing customization of display names by communities, so it would mainly be a con for integration devs.
    - Con: Users will create new fields to replace deprecated ones, but some communities may not switch!

### Problem: Allow integrations to handle renamed fields without downtime
- The integrations table gets an additional autoincrementing column to track its version number.
- Whenever a developer updates their aliases, or changes the permissions requested by an integration, the version number is increased.
- Updates to the alias map create a new alias map (the most recent version is always stored) in the database, tied to this version number.
- Every API request specifies a version number.
- When PubPub receives an API request, it uses the alias map associated with the version number in the request
- This allows integrations to safely update their aliases, then update their alias code
    - Pro: Updating aliases only takes two steps instead of three: rename, then update the integration
    - Con: Every single request to the API needs to include a version number
    - Con: PubPub needs to store multiple manifests

My opinion is that we should avoid requiring version numbers in every request. Field renaming shouldn't be all that common once an integration is in use, so it's okay to make it a little unwieldy. It's purely a developer convenience since these aliases aren't shown to community members.

## Field validation

For now, we won't worry too much about field validation. For the MVP, we will probably at least want to offer "required" fields. Eventually, we should add another column to the fields table which will store serialized validation rules (zod schemas perhaps) that can be defined by the creator of a field. Before we do that, we'll need to decide if, how, and by whom those rules can be changed. For example, should the initial creator control the validation of a field or should it be overrideable by a community? Will we allow users to make "safe" updates to field schemas (adding properties, but not removing or renaming) or will the schemas be immutable?

